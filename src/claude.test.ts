import { jest, describe, it, expect, beforeEach, afterEach } from '@jest/globals'
import * as core from '@actions/core'
import { Anthropic } from '@anthropic-ai/sdk'
import { generatePRDescription } from './claude.js'
import { PRContext } from './types.js'

// Mock the dependencies
jest.mock('@actions/core')
jest.mock('@anthropic-ai/sdk')

const mockCore = core as jest.Mocked<typeof core>
const mockAnthropic = Anthropic as jest.MockedClass<typeof Anthropic>

describe('claude.ts', () => {
  const mockApiKey = 'test-api-key'
  const mockPRContext: PRContext = {
    prInfo: {
      number: 123,
      title: 'Test PR',
      author: 'testuser',
      baseSha: 'abc123',
      headSha: 'def456',
      url: 'https://github.com/owner/repo/pull/123'
    },
    commitMessages: 'abc123 Initial commit\ndef456 Add feature',
    diff: '+++ added file\n--- removed file'
  }

  let mockAnthropicInstance: jest.Mocked<InstanceType<typeof Anthropic>>
  let mockMessagesCreate: jest.MockedFunction<any>

  beforeEach(() => {
    jest.clearAllMocks()
    
    // Setup Anthropic mock
    mockMessagesCreate = jest.fn()
    mockAnthropicInstance = {
      messages: {
        create: mockMessagesCreate
      }
    } as any
    
    mockAnthropic.mockImplementation(() => mockAnthropicInstance)
  })

  afterEach(() => {
    jest.restoreAllMocks()
  })

  describe('generatePRDescription', () => {
    it('should generate PR description successfully', async () => {
      // Arrange
      const expectedDescription = '## Summary\nThis PR adds a new feature.\n\n## Changes Made\n- Added new functionality'
      const mockResponse = {
        content: [
          {
            type: 'text' as const,
            text: expectedDescription
          }
        ],
        usage: {
          input_tokens: 100,
          output_tokens: 50,
          cache_read_input_tokens: 0
        }
      }

      mockMessagesCreate.mockResolvedValue(mockResponse)

      // Act
      const result = await generatePRDescription(mockApiKey, mockPRContext)

      // Assert
      expect(result).toBe(expectedDescription)
      expect(mockAnthropic).toHaveBeenCalledWith({ apiKey: mockApiKey })
      expect(mockMessagesCreate).toHaveBeenCalledWith({
        model: 'claude-3-5-haiku-latest',
        max_tokens: 1000,
        temperature: 0.3,
        system: [
          {
            type: 'text',
            text: expect.stringContaining('You are a technical writer'),
            cache_control: { type: 'ephemeral' }
          }
        ],
        messages: [
          {
            role: 'user',
            content: [
              {
                type: 'text',
                text: 'Please analyze this pull request and generate a description:\n\n'
              },
              {
                type: 'text',
                text: expect.stringContaining('Pull Request Title: Test PR'),
                cache_control: { type: 'ephemeral' }
              }
            ]
          }
        ]
      })

      expect(mockCore.info).toHaveBeenCalledWith('Generating PR description with Claude...')
      expect(mockCore.info).toHaveBeenCalledWith('Generated PR description successfully')
      expect(mockCore.info).toHaveBeenCalledWith('Token usage: input=100, output=50')
    })

    it('should log cache hit information when cache is used', async () => {
      // Arrange
      const mockResponse = {
        content: [
          {
            type: 'text' as const,
            text: 'Generated description'
          }
        ],
        usage: {
          input_tokens: 50,
          output_tokens: 25,
          cache_read_input_tokens: 75
        }
      }

      mockMessagesCreate.mockResolvedValue(mockResponse)

      // Act
      await generatePRDescription(mockApiKey, mockPRContext)

      // Assert
      expect(mockCore.info).toHaveBeenCalledWith('Cache hit! Saved tokens: 75')
      expect(mockCore.info).toHaveBeenCalledWith('Cache hit rate: 60%')
    })

    it('should handle empty content in response', async () => {
      // Arrange
      const mockResponse = {
        content: [],
        usage: {
          input_tokens: 100,
          output_tokens: 0,
          cache_read_input_tokens: 0
        }
      }

      mockMessagesCreate.mockResolvedValue(mockResponse)

      // Act & Assert
      await expect(generatePRDescription(mockApiKey, mockPRContext))
        .rejects
        .toThrow('Empty description generated by Claude')
    })

    it('should handle non-text content in response', async () => {
      // Arrange
      const mockResponse = {
        content: [
          {
            type: 'image' as const,
            source: { type: 'base64', media_type: 'image/png', data: 'base64data' }
          }
        ],
        usage: {
          input_tokens: 100,
          output_tokens: 50,
          cache_read_input_tokens: 0
        }
      }

      mockMessagesCreate.mockResolvedValue(mockResponse)

      // Act & Assert
      await expect(generatePRDescription(mockApiKey, mockPRContext))
        .rejects
        .toThrow('Empty description generated by Claude')
    })

    it('should handle null content in response', async () => {
      // Arrange
      const mockResponse = {
        content: null,
        usage: {
          input_tokens: 100,
          output_tokens: 0,
          cache_read_input_tokens: 0
        }
      }

      mockMessagesCreate.mockResolvedValue(mockResponse)

      // Act & Assert
      await expect(generatePRDescription(mockApiKey, mockPRContext))
        .rejects
        .toThrow('Empty description generated by Claude')
    })

    it('should handle API errors from Anthropic', async () => {
      // Arrange
      const apiError = new Error('API quota exceeded')
      mockMessagesCreate.mockRejectedValue(apiError)

      // Act & Assert
      await expect(generatePRDescription(mockApiKey, mockPRContext))
        .rejects
        .toThrow('Failed to generate description with Claude: Error: API quota exceeded')
    })

    it('should handle network errors', async () => {
      // Arrange
      const networkError = new Error('Network timeout')
      mockMessagesCreate.mockRejectedValue(networkError)

      // Act & Assert
      await expect(generatePRDescription(mockApiKey, mockPRContext))
        .rejects
        .toThrow('Failed to generate description with Claude: Error: Network timeout')
    })

    it('should log context information correctly', async () => {
      // Arrange
      const mockResponse = {
        content: [
          {
            type: 'text' as const,
            text: 'Test description'
          }
        ],
        usage: {
          input_tokens: 100,
          output_tokens: 50,
          cache_read_input_tokens: 0
        }
      }

      mockMessagesCreate.mockResolvedValue(mockResponse)

      const largePRContext: PRContext = {
        ...mockPRContext,
        commitMessages: Array(10).fill('commit message').join('\n'),
        diff: Array(100).fill('+ line of code').join('\n')
      }

      // Act
      await generatePRDescription(mockApiKey, largePRContext)

      // Assert
      expect(mockCore.info).toHaveBeenCalledWith(
        expect.stringMatching(/Context size: \d+ characters/)
      )
      expect(mockCore.info).toHaveBeenCalledWith(
        'Commit messages found: 10 commits'
      )
      expect(mockCore.info).toHaveBeenCalledWith(
        'Diff lines: 100 lines'
      )
    })

    it('should include correct system prompt', async () => {
      // Arrange
      const mockResponse = {
        content: [
          {
            type: 'text' as const,
            text: 'Test description'
          }
        ],
        usage: {
          input_tokens: 100,
          output_tokens: 50,
          cache_read_input_tokens: 0
        }
      }

      mockMessagesCreate.mockResolvedValue(mockResponse)

      // Act
      await generatePRDescription(mockApiKey, mockPRContext)

      // Assert
      const call = mockMessagesCreate.mock.calls[0][0]
      expect(call.system[0].text).toContain('You are a technical writer')
      expect(call.system[0].text).toContain('## Summary')
      expect(call.system[0].text).toContain('## Changes Made')
      expect(call.system[0].text).toContain('Be concise')
      expect(call.system[0].text).toContain('ONLY the markdown content')
    })

    it('should format context content correctly', async () => {
      // Arrange
      const mockResponse = {
        content: [
          {
            type: 'text' as const,
            text: 'Test description'
          }
        ],
        usage: {
          input_tokens: 100,
          output_tokens: 50,
          cache_read_input_tokens: 0
        }
      }

      mockMessagesCreate.mockResolvedValue(mockResponse)

      // Act
      await generatePRDescription(mockApiKey, mockPRContext)

      // Assert
      const call = mockMessagesCreate.mock.calls[0][0]
      const contextContent = call.messages[0].content[1].text
      
      expect(contextContent).toContain('Pull Request Title: Test PR')
      expect(contextContent).toContain('Pull Request Author: testuser')
      expect(contextContent).toContain('Commit Messages:')
      expect(contextContent).toContain('abc123 Initial commit')
      expect(contextContent).toContain('Complete Code Diff:')
      expect(contextContent).toContain('+++ added file')
    })
  })
})