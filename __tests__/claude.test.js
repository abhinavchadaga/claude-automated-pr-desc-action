import {
  jest,
  describe,
  it,
  expect,
  beforeEach,
  afterEach
} from '@jest/globals'
import * as core from '@actions/core'
import { Anthropic, _mockMessagesCreate } from '@anthropic-ai/sdk'
import { generatePRDescription } from '../src/claude.js'

describe('claude.js', () => {
  const mockApiKey = 'test-api-key'
  const mockPRContext = {
    prInfo: {
      number: 123,
      title: 'Test PR',
      author: 'testuser',
      baseSha: 'abc123',
      headSha: 'def456',
      url: 'https://github.com/owner/repo/pull/123'
    },
    commitMessages: 'abc123 Initial commit\ndef456 Add feature',
    diff: '+++ added file\n--- removed file'
  }

  beforeEach(() => {
    jest.clearAllMocks()
  })

  afterEach(() => {
    jest.restoreAllMocks()
  })

  describe('generatePRDescription', () => {
    it('should generate PR description successfully', async () => {
      const expectedDescription =
        '## Summary\nThis PR adds a new feature.\n\n## Changes Made\n- Added new functionality'
      const mockResponse = {
        content: [
          {
            type: 'text',
            text: expectedDescription
          }
        ],
        usage: {
          input_tokens: 100,
          output_tokens: 50,
          cache_read_input_tokens: 0
        }
      }

      _mockMessagesCreate.mockResolvedValue(mockResponse)

      const result = await generatePRDescription(mockApiKey, mockPRContext)

      expect(result).toBe(expectedDescription)
      expect(Anthropic).toHaveBeenCalledWith({ apiKey: mockApiKey })
      expect(_mockMessagesCreate).toHaveBeenCalledWith({
        model: 'claude-3-5-haiku-latest',
        max_tokens: 1000,
        temperature: 0.3,
        system: [
          {
            type: 'text',
            text: expect.stringContaining('You are a technical writer'),
            cache_control: { type: 'ephemeral' }
          }
        ],
        messages: [
          {
            role: 'user',
            content: [
              {
                type: 'text',
                text: 'Please analyze this pull request and generate a description:\n\n'
              },
              {
                type: 'text',
                text: expect.stringContaining('Pull Request Title: Test PR'),
                cache_control: { type: 'ephemeral' }
              }
            ]
          }
        ]
      })

      expect(core.info).toHaveBeenCalledWith(
        'Generating PR description with Claude...'
      )
      expect(core.info).toHaveBeenCalledWith(
        'Generated PR description successfully'
      )
      expect(core.info).toHaveBeenCalledWith(
        'Token usage: input=100, output=50'
      )
    })

    it('should log cache hit information when cache is used', async () => {
      const mockResponse = {
        content: [
          {
            type: 'text',
            text: 'Generated description'
          }
        ],
        usage: {
          input_tokens: 50,
          output_tokens: 25,
          cache_read_input_tokens: 75
        }
      }

      _mockMessagesCreate.mockResolvedValue(mockResponse)

      await generatePRDescription(mockApiKey, mockPRContext)

      expect(core.info).toHaveBeenCalledWith('Cache hit! Saved tokens: 75')
      expect(core.info).toHaveBeenCalledWith('Cache hit rate: 60%')
    })

    it('should handle empty content in response', async () => {
      const mockResponse = {
        content: [],
        usage: {
          input_tokens: 100,
          output_tokens: 0,
          cache_read_input_tokens: 0
        }
      }

      _mockMessagesCreate.mockResolvedValue(mockResponse)

      await expect(
        generatePRDescription(mockApiKey, mockPRContext)
      ).rejects.toThrow('Empty description generated by Claude')
    })

    it('should handle non-text content in response', async () => {
      const mockResponse = {
        content: [
          {
            type: 'image',
            source: {
              type: 'base64',
              media_type: 'image/png',
              data: 'base64data'
            }
          }
        ],
        usage: {
          input_tokens: 100,
          output_tokens: 50,
          cache_read_input_tokens: 0
        }
      }

      _mockMessagesCreate.mockResolvedValue(mockResponse)

      await expect(
        generatePRDescription(mockApiKey, mockPRContext)
      ).rejects.toThrow('Empty description generated by Claude')
    })

    it('should handle null content in response', async () => {
      const mockResponse = {
        content: null,
        usage: {
          input_tokens: 100,
          output_tokens: 0,
          cache_read_input_tokens: 0
        }
      }

      _mockMessagesCreate.mockResolvedValue(mockResponse)

      await expect(
        generatePRDescription(mockApiKey, mockPRContext)
      ).rejects.toThrow('Empty description generated by Claude')
    })

    it('should handle API errors from Anthropic', async () => {
      const apiError = new Error('API quota exceeded')
      _mockMessagesCreate.mockRejectedValue(apiError)

      await expect(
        generatePRDescription(mockApiKey, mockPRContext)
      ).rejects.toThrow(
        'Failed to generate description with Claude: Error: API quota exceeded'
      )
    })

    it('should handle network errors', async () => {
      const networkError = new Error('Network timeout')
      _mockMessagesCreate.mockRejectedValue(networkError)

      await expect(
        generatePRDescription(mockApiKey, mockPRContext)
      ).rejects.toThrow(
        'Failed to generate description with Claude: Error: Network timeout'
      )
    })

    it('should log context information correctly', async () => {
      const mockResponse = {
        content: [
          {
            type: 'text',
            text: 'Test description'
          }
        ],
        usage: {
          input_tokens: 100,
          output_tokens: 50,
          cache_read_input_tokens: 0
        }
      }

      _mockMessagesCreate.mockResolvedValue(mockResponse)

      const largePRContext = {
        ...mockPRContext,
        commitMessages: Array(10).fill('commit message').join('\n'),
        diff: Array(100).fill('+ line of code').join('\n')
      }

      await generatePRDescription(mockApiKey, largePRContext)

      expect(core.info).toHaveBeenCalledWith(
        expect.stringMatching(/Context size: \d+ characters/)
      )
      expect(core.info).toHaveBeenCalledWith(
        'Commit messages found: 10 commits'
      )
      expect(core.info).toHaveBeenCalledWith('Diff lines: 100 lines')
    })

    it('should include correct system prompt', async () => {
      const mockResponse = {
        content: [
          {
            type: 'text',
            text: 'Test description'
          }
        ],
        usage: {
          input_tokens: 100,
          output_tokens: 50,
          cache_read_input_tokens: 0
        }
      }

      _mockMessagesCreate.mockResolvedValue(mockResponse)

      await generatePRDescription(mockApiKey, mockPRContext)

      const call = _mockMessagesCreate.mock.calls[0][0]
      expect(call.system[0].text).toContain('You are a technical writer')
      expect(call.system[0].text).toContain('## Summary')
      expect(call.system[0].text).toContain('## Changes Made')
      expect(call.system[0].text).toContain('Be concise')
      expect(call.system[0].text).toContain('ONLY the markdown content')
    })

    it('should format context content correctly', async () => {
      const mockResponse = {
        content: [
          {
            type: 'text',
            text: 'Test description'
          }
        ],
        usage: {
          input_tokens: 100,
          output_tokens: 50,
          cache_read_input_tokens: 0
        }
      }

      _mockMessagesCreate.mockResolvedValue(mockResponse)

      await generatePRDescription(mockApiKey, mockPRContext)

      const call = _mockMessagesCreate.mock.calls[0][0]
      const contextContent = call.messages[0].content[1].text

      expect(contextContent).toContain('Pull Request Title: Test PR')
      expect(contextContent).toContain('Pull Request Author: testuser')
      expect(contextContent).toContain('Commit Messages:')
      expect(contextContent).toContain('abc123 Initial commit')
      expect(contextContent).toContain('Complete Code Diff:')
      expect(contextContent).toContain('+++ added file')
    })
  })
})
